<!DOCTYPE html> <html lang="EN"> <head> <meta charset="utf-8"> <title>For</title> <style>html body{margin:0 auto 0 auto;padding:20px;max-width:1024px;font-family:sans-serif;font-size:14pt;overflow-y:scroll;}html body a{text-decoration:none;}html body a[href]{color:#0055AA;}html body a[href]:hover{color:#0088EE;}html body pre{background:#FAFAFA;border:1px solid #DDDDDD;padding:0.75em;overflow-x:auto;}html body pre >code a[href]{color:#223388;}article.project h1{font-size:1.7em;}article.project h1,article.project h2,article.project h3,article.project h4,article.project h5,article.project h6{margin:0.2em 0 0.1em 0;text-indent:1em;}article.project >header{text-align:center;}article.project >header img.logo{display:block;margin:auto;max-height:170px;}article.project >header h1{display:inline-block;text-indent:0;font-size:2.5em;}article.project >header .version{vertical-align:bottom;}article.project >header .languages{margin-top:-0.5em;text-transform:capitalize;}article.project >header .description{margin:0;}article.project >header .pages{margin-top:0.5em;font-size:1.2em;text-transform:capitalize;}article.project >header .pages a{display:inline-block;padding:0 0.2em;}article.project >section{margin:1em 0 1em 0;}article.project >section img{max-width:100%;}article.project #index >ul{list-style:none;margin:0;padding:0;}article.project .row label{display:inline-block;min-width:8em;}article.project #system .row{display:flex;}article.project #system #dependencies{display:inline;margin:0;padding:0;}article.project #system #dependencies li{display:inline;padding:0 0.2em;}article.project #system #author label{vertical-align:top;}article.project #system #author ul{display:inline-block;margin:0;padding:0;list-style:none;}article.project #toc nav>*{margin-left:1em;display:block;}article.definition{margin:1em 0 0 0;}article.definition >header h1,article.definition >header h2,article.definition >header h3,article.definition >header h4,article.definition >header h5,article.definition >header h6{text-indent:0;display:inline-block;}article.definition >header ul{display:inline-block;list-style:none;margin:0;padding:0;}article.definition >header ul li{display:inline-block;padding:0 0.2em 0 0;}article.definition >header .visibility{display:none;}article.definition >header .visibility,article.definition >header .type{text-transform:lowercase;}article.definition >header .source-link{visibility:hidden;float:right;}article.definition >header .source-link:after{visibility:visible;content:"[SRC]";}article.definition .docstring{margin:0 0 0 1em;}article.definition .docstring pre{font-size:0.8em;white-space:pre-wrap;}.definition.package >header ul.nicknames{display:inline-block;list-style:none;margin:0;padding:0 0 0 1em;}.definition.package >header ul.nicknames li{display:inline;}.definition.package >header ul.nicknames:before{content:"(";}.definition.package >header ul.nicknames:after{content:")";}.definition.package ul.definitions{margin:0;list-style:none;padding:0 0 0 0.5em;}.definition.callable >header .name:before,.definition.type >header .name:before{content:"(";font-weight:normal;}.definition.callable >header .arguments:after,.definition.type >header .arguments:after{content:")";}.definition.callable >header .arguments .arguments:before,.definition.type >header .arguments .arguments:before{content:"(";}.definition.callable >header .arguments .argument,.definition.type >header .arguments .argument{padding:0;}.definition.callable >header .arguments .argument.lambda-list-keyword,.definition.type >header .arguments .argument.lambda-list-keyword{color:#991155;}.definition li>mark{background:none;border-left:0.3em solid #0088EE;padding-left:0.3em;display:block;}@media (min-width: 1300px){html body{padding-left:16em;}article.project #toc{margin:0;position:fixed;left:0;top:0;bottom:0;width:15em;overflow-y:auto;background:#F0F0F0;border-right:1px solid #A0A0A0;}}</style> </head> <body> <article class="project"> <header>  <img class="logo" src="for-logo.png" alt="Logo">    <span class="version">1.2.0</span>    <p class="description">An extensible iteration macro library.</p>   </header> <section id="toc"> <h2>Table of Contents</h2> <nav> <a href="#project">Top</a>  <a href="#documentation">Documentation</a> <nav> <a href="#about_for">About For</a>  <a href="#how_to">How To</a>  <a href="#extending_for">Extending FOR</a>  <a href="#bindings">Bindings</a>  <a href="#clauses">Clauses</a>  <a href="#iterators">Iterators</a> </nav>  <a href="#system">System</a>  <a href="#system">Packages</a> <nav> <a href="#PACKAGE%20FOR">FOR</a> </nav>  </nav> </section>  <section id="documentation"><h2 id="about_for">About For</h2> <p>For is a library for an extensible iteration macro. It allows you to write concise looping constructs similar to <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> and <code>iterate</code>. Unlike loop however it is extensible and sensible, and unlike iterate it does not require code-walking and is easier to extend.</p> <h2 id="how_to">How To</h2> <p>Load For using ASDF or Quicklisp.</p> <pre><code>(ql:quickload :for)
</code></pre> <p>Now we can use the <code><a href="#MACRO-FUNCTION%20FOR%3AFOR" class="xref">for</a></code> macro to do iteration. Most of the constructs you know from <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> are available with the same name in For.</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING" class="xref">(</a>for:for ((li in (<a href="http://l1sp.org/cl/list" class="xref">list</a> 1 2 3 4))
          (vi across #(a b c d)))
  (format <a href="http://l1sp.org/cl/t" class="xref">T</a> &quot;~&amp;~a ~a&quot; li vi))
</code></pre> <p>In <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> this might look as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/loop" class="xref">loop</a> for li in (<a href="http://l1sp.org/cl/list" class="xref">list</a> 1 2 3 4)
      for vi across #(a b c d)
      do (<a href="http://l1sp.org/cl/format" class="xref">format</a> T &quot;~&amp;~a ~a&quot; li vi))
</code></pre> <p>Unlike <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> and <code>iterate</code>, <code><a href="#MACRO-FUNCTION%20FOR%3AFOR" class="xref">for</a></code> makes a distinction between &quot;bindings&quot; and body forms. Body forms can also contain clauses:</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING" class="xref">(</a>for:for ((li in (<a href="http://l1sp.org/cl/list" class="xref">list</a> 1 2 3 4)))
  (thereis (evenp li)))
</code></pre> <p>In <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> this might look as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/loop" class="xref">loop</a> for li in (<a href="http://l1sp.org/cl/list" class="xref">list</a> 1 2 3 4)
      thereis (<a href="http://l1sp.org/cl/evenp" class="xref">evenp</a> li))
</code></pre> <p>Naturally, there's also accumulation bindings:</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING" class="xref">(</a>for:for ((randoms collecting (random 10)))
  (until (= 10 (length randoms))))
</code></pre> <p>In <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> this might look as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/loop" class="xref">loop</a> collect (<a href="http://l1sp.org/cl/random" class="xref">random</a> 10) into randoms
      until (<a href="http://l1sp.org/cl/%3D" class="xref">=</a> 10 (<a href="http://l1sp.org/cl/length" class="xref">length</a> randoms)))
</code></pre> <p>You might realise that the above is a rather inefficient way of writing the loop. Instead we can also use the <code><a href="#BINDING%20FOR%3AREPEAT" class="xref">repeat</a></code> binding:</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING" class="xref">(</a>for:for ((i repeat 10)
          (randoms collecting (random 10))))
</code></pre> <p>In <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> this might look as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/loop" class="xref">loop</a> repeat 10
      collect (<a href="http://l1sp.org/cl/random" class="xref">random</a> 10))
</code></pre> <p>If we have multiple bindings or clauses that might have useful values to return, all of them are returned:</p> <pre><code>(for:for ((a over *random-state* :limit 10)
          (b collect a))
  (thereis (evenp a)))
</code></pre> <p>In <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> this might look as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/loop" class="xref">loop</a> with iterator = (for-iterator:make-iterator <a href="http://l1sp.org/cl/%2Arandom-state%2A" class="xref">*random-state*</a> :limit 10)
      while (for-iterator:has-more iterator)
      for a = (for-iterator:next iterator)
      collect a into b
      when (<a href="http://l1sp.org/cl/evenp" class="xref">evenp</a> a)
      return (<a href="http://l1sp.org/cl/values" class="xref">values</a> T b))
</code></pre> <p>In order for short-circuiting clauses to have highest priority on values, clause-values are always returned first followed by binding values. Otherwise the order follows the declaration order of the respective clauses/bindings. Note that clauses must appear as a &quot;top-level&quot; form within the <code><a href="#MACRO-FUNCTION%20FOR%3AFOR" class="xref">for</a></code> body and cannot appear as the result of a macroexpansion.</p> <p>For also features a generic iterator construct that allows you to iterate over a multitude of different data types without having to do a case-distinction by yourself. We already saw this with the <code>over *random-state*</code> binding from the previous example.</p> <pre><code>(for:for ((a over '(1 2 3))
          (b over #(a b c))
          (c over (for:for ((table as (make-hash-table))) 
                    (setf (gethash (random 10) table) (random 10)) (repeat 3)))
          (d over *package*)
          (e over *random-state*)
          (f over (directory (merge-pathnames &quot;*.*&quot; (user-homedir-pathname))))
          (g over (make-string-input-stream &quot;Hi!&quot;)))
  (print (list a b c d e f g)))
</code></pre> <p><code><a href="#BINDING%20FOR%3AOVER" class="xref">over</a></code> will also automatically support iterating over additional sequence types if your implementation supports the extensible sequences protocol. Note that the <code><a href="#BINDING%20FOR%3AOVER" class="xref">over</a></code> iterator construct can be slower than a tailored iteration construct.</p> <p>Some iterators also support updating the current element. If you require doing so, you can use the <code><a href="#BINDING%20FOR%3AUPDATING" class="xref">updating</a></code> binding.</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING" class="xref">(</a>for:for ((list as (<a href="http://l1sp.org/cl/list" class="xref">list</a> 1 2 3 4 5))
          (item updating <a href="http://l1sp.org/cl/list" class="xref">list</a>))
  (setf item (expt item item)))
</code></pre> <p>In <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> this might look as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/loop" class="xref">loop</a> with list = (<a href="http://l1sp.org/cl/list" class="xref">list</a> 1 2 3 4 5)
      with iterator = (for-iterator:make-iterator list)
      while (for-iterator:has-more iterator)
      do (for-iterator:next iterator)
         (symbol-macrolet ((item (for-iterator:current iterator)))
           (setf item (<a href="http://l1sp.org/cl/expt" class="xref">expt</a> item item)))
      finally (<a href="http://l1sp.org/cl/return" class="xref">return</a> list))
</code></pre> <p>Some of the bindings also support destructuring the current item by a destructuring-lambda-list.</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING" class="xref">(</a>for:for (((type &amp;key object limit) in '((counter :limit 5)
                                         (package :object *package*))))
  (format <a href="http://l1sp.org/cl/t" class="xref">T</a> &quot;~&amp;Type: ~a~@[ Object: ~a~]~@[ Limit: ~a~]&quot; type object limit))
</code></pre> <p>In <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> this might look as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/loop" class="xref">loop</a> for list in '((counter :limit 5)
                    (package :object *package*))
      do (<a href="http://l1sp.org/cl/destructuring-bind" class="xref">destructuring-bind</a> (type &amp;key object limit) list
           (<a href="http://l1sp.org/cl/format" class="xref">format</a> T &quot;~&amp;Type: ~a~@[ Object: ~a~]~@[ Limit: ~a~]&quot; type object limit)))
</code></pre> <p>You can check a binding's or clause's documentation with <code>(documentation 'in 'for:binding)</code> which will tell you whether it supports destructuring through <code><a href="#MACRO-FUNCTION%20FOR%3AUPDATE" class="xref">update</a></code>.</p> <p>Sometimes you may want to iterate over multiple things in sequence rather than in parallel. For this you can use the <code><a href="#BINDING%20FOR%3ABEING" class="xref">being</a></code> binding, which allows you to pass a list of sub-bindings to sequentially use.</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING" class="xref">(</a>for:for (((k v) being
           (in '((駅 station) (出口 exit) (特急 express-train)))
           (across #((勉強 studying) (宿題 home-work) (授業 lesson) (試験 exam)))))
  (format <a href="http://l1sp.org/cl/t" class="xref">T</a> &quot;~&amp;~a: ~a&quot; k v))
</code></pre> <p>In <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> this might look as follows:</p> <pre><code>(progn (<a href="http://l1sp.org/cl/loop" class="xref">loop</a> for (k v) in '((駅 station) (出口 exit) (特急 express-train))
             do (<a href="http://l1sp.org/cl/format" class="xref">format</a> T &quot;~&amp;~a: ~a&quot; k v))
       (<a href="http://l1sp.org/cl/loop" class="xref">loop</a> for (k v) across #((勉強 studying) (宿題 home-work) (授業 lesson) (試験 exam))
             do (<a href="http://l1sp.org/cl/format" class="xref">format</a> T &quot;~&amp;~a: ~a&quot; k v)))
</code></pre> <p>If a binding should only be updated based on a condition, there's the <code><a href="#MACRO-FUNCTION%20FOR%3AWHEN" class="xref">when</a></code> and <code><a href="#MACRO-FUNCTION%20FOR%3AUNLESS" class="xref">unless</a></code> bindings that defer based on a test.</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING" class="xref">(</a>for:for ((random = (random 10))
          (list when (evenp random) collect random))
  (until (= 10 (length list))))
</code></pre> <p>In <code><a href="#MACRO-FUNCTION%20FOR%3ALOOP" class="xref">loop</a></code> this might look as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/loop" class="xref">loop</a> with list = ()
      for random = (<a href="http://l1sp.org/cl/random" class="xref">random</a> 10)
      when (<a href="http://l1sp.org/cl/evenp" class="xref">evenp</a> random)
      do <a href="http://l1sp.org/cl/cons" class="xref">(</a><a href="http://l1sp.org/cl/push" class="xref">push</a> random list)
      until (<a href="http://l1sp.org/cl/%3D" class="xref">=</a> 10 (<a href="http://l1sp.org/cl/length" class="xref">length</a> list))
      finally (<a href="http://l1sp.org/cl/return" class="xref">return</a> (nreverse list)))
</code></pre> <p>The following bindings are included in the <code>for-minimal</code> package:</p> <ul> <li><code><a href="#FUNCTION%20FOR%3A%3D" class="xref">=</a></code></li> <li><code><a href="#BINDING%20FOR%3AACROSS" class="xref">across</a></code></li> <li><code><a href="#BINDING%20FOR%3AAPPENDING" class="xref">appending</a></code> / <code><a href="#FUNCTION%20FOR%3AAPPEND" class="xref">append</a></code></li> <li><code><a href="#BINDING%20FOR%3AAS" class="xref">as</a></code></li> <li><code><a href="#BINDING%20FOR%3ABEING" class="xref">being</a></code></li> <li><code><a href="#BINDING%20FOR%3ACOLLECTING" class="xref">collecting</a></code> / <code><a href="#BINDING%20FOR%3ACOLLECT" class="xref">collect</a></code></li> <li><code><a href="#BINDING%20FOR%3ACOUNTING" class="xref">counting</a></code> / <code><a href="#FUNCTION%20FOR%3ACOUNT" class="xref">count</a></code></li> <li><code><a href="#BINDING%20FOR%3AFROM" class="xref">from</a></code></li> <li><code><a href="#BINDING%20FOR%3AIN" class="xref">in</a></code></li> <li><code><a href="#BINDING%20FOR%3ALINES-OF" class="xref">lines-of</a></code></li> <li><code><a href="#BINDING%20FOR%3AMAXIMIZING" class="xref">maximizing</a></code> / <code><a href="#BINDING%20FOR%3AMAXIMIZE" class="xref">maximize</a></code></li> <li><code><a href="#BINDING%20FOR%3AMINIMIZING" class="xref">minimizing</a></code> / <code><a href="#BINDING%20FOR%3AMINIMIZE" class="xref">minimize</a></code></li> <li><code><a href="#BINDING%20FOR%3ANCONCING" class="xref">nconcing</a></code> / <code><a href="#FUNCTION%20FOR%3ANCONC" class="xref">nconc</a></code></li> <li><code><a href="#BINDING%20FOR%3AON" class="xref">on</a></code></li> <li><code><a href="#BINDING%20FOR%3AOVER" class="xref">over</a></code></li> <li><code><a href="#BINDING%20FOR%3ARANGING" class="xref">ranging</a></code> / <code><a href="#BINDING%20FOR%3ARANGE" class="xref">range</a></code></li> <li><code><a href="#BINDING%20FOR%3AREDUCING" class="xref">reducing</a></code> / <code><a href="#FUNCTION%20FOR%3AREDUCE" class="xref">reduce</a></code></li> <li><code><a href="#BINDING%20FOR%3AREPEATING" class="xref">repeating</a></code> / <code><a href="#BINDING%20FOR%3AREPEAT" class="xref">repeat</a></code></li> <li><code><a href="#BINDING%20FOR%3ASUMMING" class="xref">summing</a></code> / <code><a href="#BINDING%20FOR%3ASUM" class="xref">sum</a></code></li> <li><code><a href="#BINDING%20FOR%3ASYMBOLS" class="xref">symbols</a></code></li> <li><code><a href="#BINDING%20FOR%3ATABLE-KEYS" class="xref">table-keys</a></code></li> <li><code><a href="#BINDING%20FOR%3ATABLE-PAIRS" class="xref">table-pairs</a></code></li> <li><code><a href="#BINDING%20FOR%3ATABLE-VALUES" class="xref">table-values</a></code></li> <li><code><a href="#MACRO-FUNCTION%20FOR%3AUNLESS" class="xref">unless</a></code></li> <li><code><a href="#BINDING%20FOR%3AUPDATING" class="xref">updating</a></code> / <code><a href="#MACRO-FUNCTION%20FOR%3AUPDATE" class="xref">update</a></code></li> <li><code><a href="#MACRO-FUNCTION%20FOR%3AWHEN" class="xref">when</a></code></li> </ul> <p>The following clauses are included in the <code>for-minimal</code> package:</p> <ul> <li><code><a href="#CLAUSE%20FOR%3AALWAYS" class="xref">always</a></code></li> <li><code><a href="#CLAUSE%20FOR%3ANEVER" class="xref">never</a></code></li> <li><code><a href="#CLAUSE%20FOR%3ARETURNING" class="xref">returning</a></code></li> <li><code><a href="#CLAUSE%20FOR%3ATHEREIS" class="xref">thereis</a></code></li> <li><code><a href="#CLAUSE%20FOR%3AUNTIL" class="xref">until</a></code></li> <li><code><a href="#CLAUSE%20FOR%3AWHILE" class="xref">while</a></code></li> </ul> <p>Iterator classes for the following types is included in the <code>for-iterator</code> package:</p> <ul> <li><code><a href="#FUNCTION%20FOR%3ALIST" class="xref">list</a></code></li> <li><code><a href="#FUNCTION%20FOR%3AVECTOR" class="xref">vector</a></code></li> <li><code><a href="#CLASS%20FOR%3AARRAY" class="xref">array</a></code></li> <li><code><a href="#CLASS%20FOR%3ASTREAM" class="xref">stream</a></code></li> <li><code><a href="#FUNCTION%20FOR%3APATHNAME" class="xref">pathname</a></code></li> <li><code><a href="#STRUCTURE%20FOR%3ARANDOM-STATE" class="xref">random-state</a></code></li> <li><code><a href="#STRUCTURE%20FOR%3APACKAGE" class="xref">package</a></code></li> <li><code><a href="#STRUCTURE%20FOR%3AHASH-TABLE" class="xref">hash-table</a></code> each item is a list of key and value.</li> </ul> <h2 id="extending_for">Extending FOR</h2> <p>Both bindings and clauses are defined in terms of functions that return three values:</p> <ol> <li>A surrounding form<br> Surrounding forms will be wrapped around the rest of the expanded for by appending the rest to it. This happens through <code><a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING" class="xref">with-interleaving</a></code>.</li> <li>A loop body form<br> The body form is put inside the loop where it will be evaluated once per iteration.</li> <li>A return value form<br> The return value form is evaluated on loop end. The position within the returned values is dependent on the clauses and bindings present during expansion. If not provided, no return value is generated. Note that this is distinct from having NIL as a third value.</li> </ol> <p>Passed to the functions are the literal arguments used in the binding or clause expression. In that way, a clause/binding function must work just like a macro would.</p> <h3 id="bindings">Bindings</h3> <p>The most primitive way to define bindings is through the <code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-DIRECT-BINDING" class="xref">define-direct-binding</a></code> macro. This defines a verbatim binding function as described above. Note that the loop body forms of bindings will always be evaluated before the proper for body. </p> <p>In most cases you will want the arguments that are passed to the binding to be evaluated only once, before the loop starts properly. The <code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-VALUE-BINDING" class="xref">define-value-binding</a></code> macro will help you with that. Each argument you specify will be bound to a gensym within the definition body, and is automatically expanded to a variable with the value that is used in the binding. <code>&amp;aux</code> arguments receive special treatment as they are expanded like regular variables and thus allow you to easily define helper variables necessary during iteration.</p> <p>Let's look at an example binding definition:</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-DIRECT-BINDING" class="xref">(</a><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-VALUE-BINDING" class="xref">define-value-binding</a> across (var vector &amp;aux (i -1) (length (length vector)))
  <a href="http://l1sp.org/cl/append" class="xref">`(if (= ,length (incf ,i))
       (end-for)
       (update ,var (aref ,vector ,i)))</a>)
</code></pre> <p>Expanding a simple call <code>(for ((a across vec)))</code> results in this expansion (after cleaning it up a little):</p> <pre><code>(LET* ((#:VECTOR VEC)
       (#:I -1)
       (#:LENGTH (LENGTH #:VECTOR))
       (A NIL))
  (WITH-FOR-BODY
    (IF (= #:LENGTH (INCF #:I))
        (END-FOR)
        (UPDATE A (AREF #:VECTOR #:I))))
</code></pre> <p>As you can see, our only argument, <code><a href="#FUNCTION%20FOR%3AVECTOR" class="xref">vector</a></code> got expanded into a gensym-ed variable that is bound to the result of the <code><a href="#FUNCTION%20FOR%3AVECTOR" class="xref">vector</a></code> argument. Our auxiliary variables received similar treatment. Note that references to other arguments automatically get translated to their proper gensyms.</p> <p>In some cases however you'd like to re-evaluate an argument each iteration. To get this behaviour, you can use <code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-BINDING" class="xref">define-form-binding</a></code>. Here's a simple example:</p> <pre><code> <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-DIRECT-BINDING" class="xref">(</a><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-BINDING" class="xref">define-form-binding</a> = (var form)
   <a href="http://l1sp.org/cl/append" class="xref">`(update ,var ,form)</a>)
</code></pre> <p>Expanding a simple call <code>(for ((a = (* 2 2))))</code> presents us with:</p> <pre><code> (LET* ((A NIL))
   (WITH-FOR-BODY
     (UPDATE A (* 2 2)))
</code></pre> <p>Usually you will want form bindings if you want to accumulate the results of it over time in some manner. In that case you usually also want to return the result of the accumulation once you're done. <code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-ACCUMULATION-BINDING" class="xref">define-accumulation-binding</a></code> does exactly that. One note about form bindings is that the auxiliary variables still act the same as in the value bindings-- they automatically get expanded to bindings in the resulting loop construct.</p> <p>Let's look at an example that shows both:</p> <pre><code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-BINDING" class="xref">(</a><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-ACCUMULATION-BINDING" class="xref">define-accumulation-binding</a> collecting (var form &amp;aux (head (cons NIL NIL)) (tail head))
  <a href="http://l1sp.org/cl/append" class="xref">`(setf ,tail (setf (cdr ,tail) (cons ,form NIL))
         ,var (cdr ,head))</a>)
</code></pre> <p>Expanding <code>(for ((a collecting 2)))</code> results in:</p> <pre><code>(LET* ((#:HEAD (CONS NIL NIL)) (#:TAIL #:HEAD) (A NIL))
  (WITH-FOR-BODY
   (SETF #:TAIL (SETF (CDR #:TAIL) (CONS 2 NIL))
         A (CDR #:HEAD))
   (RETURN-FOR A))
</code></pre> <p>As before, the auxiliary arguments got expanded to variable bindings with their respective default values.</p> <p>Finally we have two variants of form and value bindings, <code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-SYMBOL-MACRO-BINDING" class="xref">define-form-symbol-macro-binding</a></code> and <code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-VALUE-SYMBOL-MACRO-BINDING" class="xref">define-value-symbol-macro-binding</a></code>. The difference to the previous definition forms here is that the <code>var</code> is not bound as a variable, but instead as a symbol macro. Its default value is the symbol-macro expansion. This is useful if you want to provide an updateable place as the iteration var, as is the case with the <code><a href="#BINDING%20FOR%3AUPDATING" class="xref">updating</a></code> binding.</p> <h3 id="clauses">Clauses</h3> <p>Clauses work the exact same as bindings in terms of the base function, which you can define with <code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-DIRECT-CLAUSE" class="xref">define-direct-clause</a></code>. Unlike bindings however, clauses simply get the body of their call as arguments, without an iteration var.</p> <p>In order to ease things a bit there is also <code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-SIMPLE-CLAUSE" class="xref">define-simple-clause</a></code> which provides the same handling for arguments as <code><a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-BINDING" class="xref">define-form-binding</a></code> does.</p> <p>One thing to note is that the surrounding forms of clauses always appear deeper than those of bindings and that the result value forms of clauses always appear before those of bindings. The loop body form of a clause appears at the exact position in the body where the clause expression previously appeared.</p> <h3 id="iterators">Iterators</h3> <p>In order to provide the generic <code><a href="#BINDING%20FOR%3AOVER" class="xref">over</a></code> iteration construct, For includes a protocol to define iterators. In order for an iterator to work, it has to subclass <code><a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">iterator</a></code> and provide three methods: <code><a href="#GENERIC-FUNCTION%20FOR%3AMAKE-ITERATOR" class="xref">make-iterator</a></code>, <code><a href="#GENERIC-FUNCTION%20FOR%3AHAS-MORE" class="xref">has-more</a></code>, and <code><a href="#GENERIC-FUNCTION%20FOR%3ANEXT" class="xref">next</a></code>. The first is merely there so that we can dispatch on the type of object we'd like to iterate over and construct an appropriate iterator for it. The second should return a generalised boolean that tells us whether we can safely call <code><a href="#GENERIC-FUNCTION%20FOR%3ANEXT" class="xref">next</a></code>. Finally, <code><a href="#GENERIC-FUNCTION%20FOR%3ANEXT" class="xref">next</a></code> itself advances the iterator and returns a new element. If sensible and possible, a method on <code>(setf current)</code> can also be provided to allow updating the current element to a new value. In order to speed up iteration in most cases, it's also useful to provide a <code><a href="#GENERIC-FUNCTION%20FOR%3ASTEP-FUNCTIONS" class="xref">step-functions</a></code> method.</p> <p>Let's look at the list iterator as an example:</p> <pre><code>(<a href="http://l1sp.org/cl/defclass" class="xref">defclass</a> list-iterator (iterator)
  ())

(<a href="http://l1sp.org/cl/defmethod" class="xref">defmethod</a> <a href="http://l1sp.org/cl/initialize-instance" class="xref">initialize-instance</a> :after ((iterator list-iterator) &amp;key object)
  (setf (object iterator) (<a href="http://l1sp.org/cl/cons" class="xref">cons</a> NIL object)))

(<a href="http://l1sp.org/cl/defmethod" class="xref">defmethod</a> has-more ((iterator list-iterator))
  (<a href="http://l1sp.org/cl/cdr" class="xref">cdr</a> (object iterator)))

(<a href="http://l1sp.org/cl/defmethod" class="xref">defmethod</a> next ((iterator list-iterator))
  (setf (object iterator) (<a href="http://l1sp.org/cl/cdr" class="xref">cdr</a> (object iterator)))
  (<a href="http://l1sp.org/cl/car" class="xref">car</a> (object iterator)))

(<a href="http://l1sp.org/cl/defmethod" class="xref">defmethod</a> (setf current) (value (iterator list-iterator))
  (setf (<a href="http://l1sp.org/cl/car" class="xref">car</a> (object iterator)) value))

(<a href="http://l1sp.org/cl/defmethod" class="xref">defmethod</a> step-functions ((iterator list-iterator))
  (let ((list (object iterator)))
    (<a href="http://l1sp.org/cl/values" class="xref">values</a>
     (lambda ()
       (setf list (<a href="http://l1sp.org/cl/cdr" class="xref">cdr</a> list))
       (<a href="http://l1sp.org/cl/car" class="xref">car</a> list))
     (lambda ()
       (<a href="http://l1sp.org/cl/cdr" class="xref">cdr</a> list))
     (lambda (value)
       (setf (<a href="http://l1sp.org/cl/car" class="xref">car</a> list) value))
     (lambda ()))))

(<a href="http://l1sp.org/cl/defmethod" class="xref">defmethod</a> make-iterator ((list <a href="http://l1sp.org/cl/list" class="xref">list</a>) &amp;key)
  (<a href="http://l1sp.org/cl/make-instance" class="xref">make-instance</a> 'list-iterator :object list))
</code></pre> <p>First we subclass <code><a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">iterator</a></code>. Next we define an initialize method in order to prepend a cons to the list. We do this so that we know the next element will always be in the cadr of the <code><a href="#GENERIC-FUNCTION%20FOR%3AOBJECT" class="xref">object</a></code> and we can still set the car of the current cons cell to update it. The <code><a href="#GENERIC-FUNCTION%20FOR%3AHAS-MORE" class="xref">has-more</a></code> test is implemented accordingly. On <code><a href="#GENERIC-FUNCTION%20FOR%3ANEXT" class="xref">next</a></code> we then simply pop off the first cons and return our new current element. The <code>(setf current)</code> can then just update the car of the <code><a href="#GENERIC-FUNCTION%20FOR%3AOBJECT" class="xref">object</a></code>. The <code><a href="#GENERIC-FUNCTION%20FOR%3ASTEP-FUNCTIONS" class="xref">step-functions</a></code> method then implements most of that logic again inside closures that avoid any CLOS dispatch. Finally we need a <code><a href="#GENERIC-FUNCTION%20FOR%3AMAKE-ITERATOR" class="xref">make-iterator</a></code> method to dispatch on lists.</p> </section>    <section id="system"> <h2>System Information</h2>  <div class="row"> <label for="version">Version:</label> <a id="version">1.2.0</a> </div>   <div class="row"> <label for="dependencies">Dependencies:</label> <ul id="dependencies"><li><a class="external" href="https://Shinmera.github.io/documentation-utils/">documentation-utils</a></li><li><a class="external" href="https://Shinmera.github.io/lambda-fiddle/">lambda-fiddle</a></li><li><a class="external" href="https://Shinmera.github.io/form-fiddle/">form-fiddle</a></li></ul> </div>   <div class="row" id="author"> <label for="author">Author:</label> <a href="mailto:shinmera@tymoon.eu">Yukari Hafner</a> </div>   <div class="row"> <label for="license">License:</label> <a id="license" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/LICENSE">zlib</a> </div>   <div class="row"> <label for="homepage">Homepage:</label> <a id="homepage" href="https://Shinmera.github.io/for/">https://Shinmera.github.io/for/</a> </div>   <div class="row"> <label for="bug-tracker">Bug Tracker:</label> <a id="bug-tracker" href="https://github.com/Shinmera/for/issues">https://github.com/Shinmera/for/issues</a> </div>   <div class="row"> <label for="sources">Sources:</label> <a id="sources" href="https://github.com/Shinmera/for.git">https://github.com/Shinmera/for.git</a> </div>  </section>    <section id="index"> <h2>Definition Index</h2> <ul> <li> <article class="definition package" id="PACKAGE FOR"> <header> <h3> <a href="#PACKAGE%20FOR">FOR</a> </h3> <ul class="nicknames"> <li>ORG.SHIRAKUMO.FOR</li> </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> <ul class="definitions"> <li> <article class="definition class" id="CLASS FOR:ARRAY-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3AARRAY-ITERATOR">ARRAY-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L90">Source</a>  </header> <div class="docstring"><pre>Iterator for general arrays.

Iteration is in row-major order.

Supports setting the current element.

See <a href="#CLASS%20FOR%3AVECTOR-ITERATOR" class="xref">VECTOR-ITERATOR</a>
See <a href="#GENERIC-FUNCTION%20FOR%3ATOTAL-LENGTH" class="xref">TOTAL-LENGTH</a></pre></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:DIRECTORY-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3ADIRECTORY-ITERATOR">DIRECTORY-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L274">Source</a>  </header> <div class="docstring"><pre>Iterator for a DIRECTORY listing.

On construction, this performs a simple DIRECTORY call on the given object
and then iterates over the result list of pathnames. Thus, the pathname must
be wild.

See <a href="#CLASS%20FOR%3ALIST-ITERATOR" class="xref">LIST-ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:HASH-TABLE-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3AHASH-TABLE-ITERATOR">HASH-TABLE-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L356">Source</a>  </header> <div class="docstring"><pre>Iterator for the key/value pairs in a package.

Each value returned by this iterator's CURRENT/NEXT is always a list of two values, the
respective key and its value.

Supports setting the current element.

See <a href="#GENERIC-FUNCTION%20FOR%3APREFETCH" class="xref">PREFETCH</a>
See <a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3AITERATOR">ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L11">Source</a>  </header> <div class="docstring"><pre>An iterator is responsible for iterating over a given data structure.

See <a href="#GENERIC-FUNCTION%20FOR%3AHAS-MORE" class="xref">HAS-MORE</a>
See <a href="#GENERIC-FUNCTION%20FOR%3ANEXT" class="xref">NEXT</a>
See <a href="#GENERIC-FUNCTION%20FOR%3ACURRENT" class="xref">CURRENT</a>
See <a href="#GENERIC-FUNCTION%20FOR%3AMAKE-ITERATOR" class="xref">MAKE-ITERATOR</a>
See <a href="#GENERIC-FUNCTION%20FOR%3AOBJECT" class="xref">OBJECT</a></pre></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:LIST-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3ALIST-ITERATOR">LIST-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L26">Source</a>  </header> <div class="docstring"><pre>Iterator for proper lists.

Supports setting the current element.

See <a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:PACKAGE-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3APACKAGE-ITERATOR">PACKAGE-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L312">Source</a>  </header> <div class="docstring"><pre>Iterator for the symbols in a package.

The type of symbols that are iterated can be set through the :STATUS initarg, which must
be a list containing any of the following keywords: :INTERNAL :EXTERNAL :INHERITED

See <a href="#GENERIC-FUNCTION%20FOR%3APREFETCH" class="xref">PREFETCH</a>
See <a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:RANDOM-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3ARANDOM-ITERATOR">RANDOM-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L285">Source</a>  </header> <div class="docstring"><pre>Iterator for random numbers.

This iterator can be constructed through a RANDOM-STATE object. The argument for RANDOM
that determines its limit can be passed through the :LIMIT initarg.

See <a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:SEQUENCE-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3ASEQUENCE-ITERATOR">SEQUENCE-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L125">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:STREAM-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3ASTREAM-ITERATOR">STREAM-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L170">Source</a>  </header> <div class="docstring"><pre>Iterator for input streams.

The stream is read through a buffer, the size of which can be set via the :BUFFER-SIZE
initarg. If :CLOSE-STREAM is set to non-NIL, CLOSE is performed on the stream upon END.

Supports setting the &quot;current&quot; element if the stream supports writing to it of course.

See <a href="#GENERIC-FUNCTION%20FOR%3ABUFFER" class="xref">BUFFER</a>
See <a href="#GENERIC-FUNCTION%20FOR%3AINDEX" class="xref">INDEX</a>
See <a href="#GENERIC-FUNCTION%20FOR%3ALIMIT" class="xref">LIMIT</a>
See <a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:STREAM-LINE-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3ASTREAM-LINE-ITERATOR">STREAM-LINE-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L227">Source</a>  </header> <div class="docstring"><pre>Iterator for line based input streams.

If :CLOSE-STREAM is set to non-NIL, CLOSE is performed on the stream upon END.

See <a href="#GENERIC-FUNCTION%20FOR%3ABUFFER" class="xref">BUFFER</a>
See <a href="#GENERIC-FUNCTION%20FOR%3ACLOSE-STREAM" class="xref">CLOSE-STREAM</a>
See <a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition class" id="CLASS FOR:VECTOR-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20FOR%3AVECTOR-ITERATOR">VECTOR-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L58">Source</a>  </header> <div class="docstring"><pre>Iterator for vectors.

Supports setting the current element.

See <a href="#GENERIC-FUNCTION%20FOR%3ASTART" class="xref">START</a>
See <a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition clause" id="CLAUSE FOR:ALWAYS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLAUSE</span> <h4 class="name"> <a href="#CLAUSE%20FOR%3AALWAYS">ALWAYS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L266">Source</a>  </header> <div class="docstring"><pre>If FORM always returns non-NIL, then T is returned.
As soon as FORM returns NIL the for is aborted with END-FOR and NIL is returned.</pre></div> </article> </li>  <li> <article class="definition clause" id="CLAUSE FOR:NEVER"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLAUSE</span> <h4 class="name"> <a href="#CLAUSE%20FOR%3ANEVER">NEVER</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L270">Source</a>  </header> <div class="docstring"><pre>If FORM never returns non-NIL, then T is returned.
As soon as FORM returns non-NIL the for is aborted with END-FOR and NIL is returned.</pre></div> </article> </li>  <li> <article class="definition clause" id="CLAUSE FOR:REPEAT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLAUSE</span> <h4 class="name"> <a href="#CLAUSE%20FOR%3AREPEAT">REPEAT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L290">Source</a>  </header> <div class="docstring"><pre>Makes sure the loop body is repeated a maximum of N times.</pre></div> </article> </li>  <li> <article class="definition clause" id="CLAUSE FOR:RETURNING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLAUSE</span> <h4 class="name"> <a href="#CLAUSE%20FOR%3ARETURNING">RETURNING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L286">Source</a>  </header> <div class="docstring"><pre>Does nothing each step, but makes sure to evaluate and return the value of FORM on END-FOR.</pre></div> </article> </li>  <li> <article class="definition clause" id="CLAUSE FOR:THEREIS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLAUSE</span> <h4 class="name"> <a href="#CLAUSE%20FOR%3ATHEREIS">THEREIS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L274">Source</a>  </header> <div class="docstring"><pre>If FORM never returns non-NIL, then NIL is returned.
As soon as FORM returns non-NIL the for is aborted with END-FOR and the non-NIL value is returned.

If KEY is passed, the result of the KEY function on the VALUE is used for the non-NIL test.</pre></div> </article> </li>  <li> <article class="definition clause" id="CLAUSE FOR:UNTIL"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLAUSE</span> <h4 class="name"> <a href="#CLAUSE%20FOR%3AUNTIL">UNTIL</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L283">Source</a>  </header> <div class="docstring"><pre>When FORM returns non-NIL, END-FOR is called.</pre></div> </article> </li>  <li> <article class="definition clause" id="CLAUSE FOR:WHILE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLAUSE</span> <h4 class="name"> <a href="#CLAUSE%20FOR%3AWHILE">WHILE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L280">Source</a>  </header> <div class="docstring"><pre>When FORM returns NIL, END-FOR is called.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L193">Source</a>  </header> <div class="docstring"><pre>Updates the var by the value of the given form every time.

If :then is passed, the first form is only used to provide the first iteration's
value of the var. Subsequent iterations will use the value of the :then form.

Supports UPDATE.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:ACROSS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AACROSS">ACROSS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L79">Source</a>  </header> <div class="docstring"><pre>Iterates over a vector, binding the current item to the var every time.

Supports UPDATE.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:APPEND"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AAPPEND">APPEND</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L213">Source</a>  </header> <div class="docstring"><pre>Appends the results of FORM into a list where the VAR points to the head of the list.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:APPENDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AAPPENDING">APPENDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L213">Source</a>  </header> <div class="docstring"><pre>Appends the results of FORM into a list where the VAR points to the head of the list.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:AS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AAS">AS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L53">Source</a>  </header> <div class="docstring"><pre>Simply binds the value of the form to the var.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:BEING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ABEING">BEING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L19">Source</a>  </header> <div class="docstring"><pre>Sequences multiple bindings onto the same var.

Expected as arguments is a list of binding expressions, except with each of them missing
the initial var as that is supplied by the var of the BEING binding.

During the iteration the var is then updated by the first inner binding until that calls
END-FOR, after which the var is then updated by the second binding and so forth until the
last binding calls END-FOR, in which case the behaviour is as usual.

Essentially this just does what you expect it would: it chains multiple bindings onto the
same var, sequentially using the next one after the one before finishes.

May support UPDATE depending on the inner bindings.

Note that only bindings that output a LET/LET* as their surrounding form are supported
without potential warnings about unused variables. The bindings also must not output the
var as a symbol macro as it is not possible to update that depending on which binding
is currently active.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:COLLECT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ACOLLECT">COLLECT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L207">Source</a>  </header> <div class="docstring"><pre>Collects the results of FORM into a list where the VAR points to the head of the list.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:COLLECTING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ACOLLECTING">COLLECTING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L207">Source</a>  </header> <div class="docstring"><pre>Collects the results of FORM into a list where the VAR points to the head of the list.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:COUNT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ACOUNT">COUNT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L244">Source</a>  </header> <div class="docstring"><pre>Increases the var by one if the FORM returns non-NIL.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:COUNTING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ACOUNTING">COUNTING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L244">Source</a>  </header> <div class="docstring"><pre>Increases the var by one if the FORM returns non-NIL.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:FROM"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AFROM">FROM</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L157">Source</a>  </header> <div class="docstring"><pre>Increases the var by a step every time up to an optional limit.

An optional BY keyword argument is accepted, which determines the step.
An optional TO keyword argument is accepted, which determines the exclusive limit.
This means (a from 0 :to 2) iterates over 0 and 1. If TO is smaller than FROM then
the variable is decreased by BY every step.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:IN"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AIN">IN</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L58">Source</a>  </header> <div class="docstring"><pre>Iterates over a list, binding the current list element to the var every time.

Supports UPDATE.

Accepts a BY keyword argument, which determines how the list is stepped.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:LINES-OF"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ALINES-OF">LINES-OF</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L178">Source</a>  </header> <div class="docstring"><pre>Iterates over the given file or stream, reading a line each time.

The stream is always closed when the For loop exits.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:MAXIMIZE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AMAXIMIZE">MAXIMIZE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L252">Source</a>  </header> <div class="docstring"><pre>Sets the var to the maximum of the values returned by FORM so far each step.

If KEY is passed, the comparison is performed by the result of the KEY function on each value.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:MAXIMIZING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AMAXIMIZING">MAXIMIZING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L252">Source</a>  </header> <div class="docstring"><pre>Sets the var to the maximum of the values returned by FORM so far each step.

If KEY is passed, the comparison is performed by the result of the KEY function on each value.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:MINIMIZE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AMINIMIZE">MINIMIZE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L259">Source</a>  </header> <div class="docstring"><pre>Sets the var to the minimum of the values returned by FORM so far each step.

If KEY is passed, the comparison is performed by the result of the KEY function on each value.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:MINIMIZING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AMINIMIZING">MINIMIZING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L259">Source</a>  </header> <div class="docstring"><pre>Sets the var to the minimum of the values returned by FORM so far each step.

If KEY is passed, the comparison is performed by the result of the KEY function on each value.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:NCONC"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ANCONC">NCONC</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L225">Source</a>  </header> <div class="docstring"><pre>Appends the results of FORM destructively into a list where the VAR points to the head of the list.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:NCONCING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ANCONCING">NCONCING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L225">Source</a>  </header> <div class="docstring"><pre>Appends the results of FORM destructively into a list where the VAR points to the head of the list.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:ON"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AON">ON</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L68">Source</a>  </header> <div class="docstring"><pre>Iterates over a list, binding the current list cons to the var every time.

Supports UPDATE.

Accepts a BY keyword argument, which determines how the list is stepped.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:OVER"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AOVER">OVER</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L87">Source</a>  </header> <div class="docstring"><pre>Iterates over a generic sequence using an ITERATOR, binding the current item to the var every step.

Supports UPDATE.

Potentially accepts arbitrary arguments, depending on which iterator is selected
for the respective object.

See FOR-ITERATOR:MAKE-ITERATOR</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:RANGE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ARANGE">RANGE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L144">Source</a>  </header> <div class="docstring"><pre>Iterates the var over the given range.

Ranges can be either decreasing or increasing. Both limits are inclusive. This means that
(a ranging 0 2) iterates over 0, 1, and 2.

An optional BY keyword argument is accepted, which determines the step.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:RANGING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ARANGING">RANGING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L144">Source</a>  </header> <div class="docstring"><pre>Iterates the var over the given range.

Ranges can be either decreasing or increasing. Both limits are inclusive. This means that
(a ranging 0 2) iterates over 0, 1, and 2.

An optional BY keyword argument is accepted, which determines the step.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:REDUCE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AREDUCE">REDUCE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L237">Source</a>  </header> <div class="docstring"><pre>Combines the results of FORM by a combination function BY into var.

On the first iteration the var is simply set to the result of the FORM. On every
successive step, the var is set to the result of calling BY with the var as the
first argument and the result of the FORM as the second argument.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:REDUCING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AREDUCING">REDUCING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L237">Source</a>  </header> <div class="docstring"><pre>Combines the results of FORM by a combination function BY into var.

On the first iteration the var is simply set to the result of the FORM. On every
successive step, the var is set to the result of calling BY with the var as the
first argument and the result of the FORM as the second argument.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:REPEAT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AREPEAT">REPEAT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L173">Source</a>  </header> <div class="docstring"><pre>Increases the var the given amount of times starting with 1.

This is the same as (a between 1 n)</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:REPEATING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AREPEATING">REPEATING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L173">Source</a>  </header> <div class="docstring"><pre>Increases the var the given amount of times starting with 1.

This is the same as (a between 1 n)</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:SUM"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ASUM">SUM</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L248">Source</a>  </header> <div class="docstring"><pre>Sums up the value of the FORM into the var.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:SUMMING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ASUMMING">SUMMING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L248">Source</a>  </header> <div class="docstring"><pre>Sums up the value of the FORM into the var.

This returns the var on END-FOR.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:SYMBOLS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ASYMBOLS">SYMBOLS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L137">Source</a>  </header> <div class="docstring"><pre>Iterates over the symbols of a package, binding the current symbol to the var every time.

Accepts an optional list of arguments that qualify the type of symbols to iterate over.
Each type must be one of :INTERNAL :EXTERNAL :INHERITED. If no arguments are given, it
defaults to (:INTERNAL :EXTERNAL :INHERITED).</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:TABLE-KEYS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ATABLE-KEYS">TABLE-KEYS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L109">Source</a>  </header> <div class="docstring"><pre>Iterates over a hash table, binding the current key to the var every time.

Supports UPDATE.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:TABLE-PAIRS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ATABLE-PAIRS">TABLE-PAIRS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L127">Source</a>  </header> <div class="docstring"><pre>Iterates over a hash table, binding a list of the current key and value to the var every time.

Supports UPDATE.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:TABLE-VALUES"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3ATABLE-VALUES">TABLE-VALUES</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L118">Source</a>  </header> <div class="docstring"><pre>Iterates over a hash table, binding the current value to the var every time.

Supports UPDATE.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:UNLESS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AUNLESS">UNLESS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L47">Source</a>  </header> <div class="docstring"><pre>Conditionally apply a binding.

The sub-binding's step form is only evaluated if the given test fails. This means that
the var is only updated and the loop can only be ended when the test returns NIL.

May support UPDATE depending on the sub-binding.</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:UPDATE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AUPDATE">UPDATE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L104">Source</a>  </header> <div class="docstring"><pre>Iterates over a generic sequence using an ITERATOR, with var being symbol macro to the current item.

You may SETF the var to update the item in the sequence, if the underlying iterator
supports doing so.

Potentially accepts arbitrary arguments, depending on which iterator is selected
for the respective object.

See FOR-ITERATOR:MAKE-ITERATOR</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:UPDATING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AUPDATING">UPDATING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L104">Source</a>  </header> <div class="docstring"><pre>Iterates over a generic sequence using an ITERATOR, with var being symbol macro to the current item.

You may SETF the var to update the item in the sequence, if the underlying iterator
supports doing so.

Potentially accepts arbitrary arguments, depending on which iterator is selected
for the respective object.

See FOR-ITERATOR:MAKE-ITERATOR</pre></div> </article> </li>  <li> <article class="definition binding" id="BINDING FOR:WHEN"> <header> <span class="visibility">EXTERNAL</span> <span class="type">BINDING</span> <h4 class="name"> <a href="#BINDING%20FOR%3AWHEN">WHEN</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/standard.lisp#L41">Source</a>  </header> <div class="docstring"><pre>Conditionally apply a binding.

The sub-binding's step form is only evaluated if the given test succeeds. This means that
the var is only updated and the loop can only be ended when the test returns non-NIL.

May support UPDATE depending on the sub-binding.</pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NUMBER</li>    <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">MORE-NUMBERS</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/code/numbers.lisp#681:0">Source</a>  </header> <div class="docstring"><pre>Return T if all of its arguments are numerically equal, NIL otherwise.</pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:APPEND"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3AAPPEND">APPEND</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">LISTS</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/code/list.lisp#404:0">Source</a>  </header> <div class="docstring"><pre>Construct and return a list by concatenating LISTS.</pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:BINDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3ABINDING">BINDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L5">Source</a>  </header> <div class="docstring"><pre>Accessor to the function that compiles the given binding.

If there is no binding named by the given symbol directly, another search is
performed using the symbol with the same symbol-name from the FOR package.

See <a href="#FUNCTION%20FOR%3AREMOVE-BINDING" class="xref">REMOVE-BINDING</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:(SETF BINDING)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3A%28SETF%20BINDING%29">(SETF BINDING)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">FUNC</li>    <li class="argument">NAME</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L10">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:CLAUSE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3ACLAUSE">CLAUSE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/clause.lisp#L5">Source</a>  </header> <div class="docstring"><pre>Accessor to the function that compiles the given clause.

If there is no clause named by the given symbol directly, another search is
performed using the symbol with the same symbol-name from the FOR package.

See <a href="#FUNCTION%20FOR%3AREMOVE-CLAUSE" class="xref">REMOVE-CLAUSE</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:(SETF CLAUSE)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3A%28SETF%20CLAUSE%29">(SETF CLAUSE)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">FUNC</li>    <li class="argument">NAME</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/clause.lisp#L10">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:COUNT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3ACOUNT">COUNT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITEM</li>    <li class="argument">SEQUENCE</li>    <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ARGS</li>    <li class="argument lambda-list-keyword">&amp;KEY</li>    <li class="argument">FROM-END</li>    <li class="argument">START</li>    <li class="argument">END</li>    <li class="argument">KEY</li>    <li class="argument">TEST</li>    <li class="argument">TEST-NOT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>Return the number of elements in SEQUENCE satisfying a test with ITEM,
   which defaults to EQL.</pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:HASH-TABLE-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3AHASH-TABLE-ITERATOR">HASH-TABLE-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">TABLE</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/toolkit.lisp#L86">Source</a>  </header> <div class="docstring"><pre>Returns a function to iterate over a hash-table.

See <a href="http://l1sp.org/cl/with-hash-table-iterator" class="xref">CL:WITH-HASH-TABLE-ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:NCONC"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3ANCONC">NCONC</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">LISTS</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/code/list.lisp#524:0">Source</a>  </header> <div class="docstring"><pre>Concatenates the lists given as arguments (by changing them)</pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:PACKAGE-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3APACKAGE-ITERATOR">PACKAGE-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PACKAGE</li>    <li class="argument">STATUSES</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/toolkit.lisp#L90">Source</a>  </header> <div class="docstring"><pre>Returns a function to iterate over a package's symbols.

See <a href="http://l1sp.org/cl/with-package-iterator" class="xref">CL:WITH-PACKAGE-ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:REDUCE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3AREDUCE">REDUCE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">FUNCTION</li>    <li class="argument">SEQUENCE</li>    <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ARGS</li>    <li class="argument lambda-list-keyword">&amp;KEY</li>    <li class="argument">KEY</li>    <li class="argument">FROM-END</li>    <li class="argument">START</li>    <li class="argument">END</li>    <li class="argument">INITIAL-VALUE</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:REMOVE-BINDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3AREMOVE-BINDING">REMOVE-BINDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L13">Source</a>  </header> <div class="docstring"><pre>Removes the given binding function.

See <a href="#FUNCTION%20FOR%3ABINDING" class="xref">BINDING</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION FOR:REMOVE-CLAUSE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20FOR%3AREMOVE-CLAUSE">REMOVE-CLAUSE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/clause.lisp#L13">Source</a>  </header> <div class="docstring"><pre>Removes the given clause function.

See <a href="#FUNCTION%20FOR%3ACLAUSE" class="xref">CLAUSE</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:BUFFER"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3ABUFFER">BUFFER</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>Accessor to the stream-iterator's buffer.

See <a href="#CLASS%20FOR%3ASTREAM-ITERATOR" class="xref">STREAM-ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF BUFFER)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20BUFFER%29">(SETF BUFFER)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NEW-VALUE</li>    <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:CLOSE-STREAM"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3ACLOSE-STREAM">CLOSE-STREAM</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>Accessor to whether the stream should be closed on END call or not.

See <a href="#CLASS%20FOR%3ASTREAM-ITERATOR" class="xref">STREAM-ITERATOR</a>
See <a href="#CLASS%20FOR%3ASTREAM-LINE-ITERATOR" class="xref">STREAM-LINE-ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF CLOSE-STREAM)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20CLOSE-STREAM%29">(SETF CLOSE-STREAM)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NEW-VALUE</li>    <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:CURRENT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3ACURRENT">CURRENT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERATOR</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L5">Source</a>  </header> <div class="docstring"><pre>Accessor to the current item of the iterator.

The behaviour is undefined if CURRENT is used before NEXT has been called for a first time.
Some (but not all) iterators may support setting the current element to a new value.

See <a href="#GENERIC-FUNCTION%20FOR%3ANEXT" class="xref">NEXT</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF CURRENT)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20CURRENT%29">(SETF CURRENT)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">VALUE</li>    <li class="argument">ITERATOR</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L6">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:END"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3AEND">END</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERATOR</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L7">Source</a>  </header> <div class="docstring"><pre>Ends the iterator and performs potential cleanup.

You should always call this function with your iterator object once you are done to ensure
proper termination.</pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:HAS-MORE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3AHAS-MORE">HAS-MORE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERATOR</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L3">Source</a>  </header> <div class="docstring"><pre>Returns a generalised boolean indicating whether the iterator has more items or not.</pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:INDEX"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3AINDEX">INDEX</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>Accessor to the current index within the buffer.

See <a href="#CLASS%20FOR%3ASTREAM-ITERATOR" class="xref">STREAM-ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF INDEX)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20INDEX%29">(SETF INDEX)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NEW-VALUE</li>    <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3AITERATOR">ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF ITERATOR)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20ITERATOR%29">(SETF ITERATOR)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NEW-VALUE</li>    <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:LIMIT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3ALIMIT">LIMIT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>Accessor to the amount of data that is currently filled in the buffer.

See <a href="#CLASS%20FOR%3ASTREAM-ITERATOR" class="xref">STREAM-ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF LIMIT)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20LIMIT%29">(SETF LIMIT)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NEW-VALUE</li>    <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:MAKE-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3AMAKE-ITERATOR">MAKE-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;KEY</li>    <li class="argument">LIMIT</li>    <li class="argument">BUFFER-SIZE</li>    <li class="argument">ELEMENT-TYPE</li>    <li class="argument">CLOSE-STREAM</li>    <li class="argument">START</li>    <li class="argument lambda-list-keyword">&amp;ALLOW-OTHER-KEYS</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L8">Source</a>  </header> <div class="docstring"><pre>Create an iterator object for the given type of object.</pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:NEXT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3ANEXT">NEXT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERATOR</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L4">Source</a>  </header> <div class="docstring"><pre>Advances the iterator by one item and returns the new item.

The behaviour is undefined if the iterator does not have more items.

See <a href="#GENERIC-FUNCTION%20FOR%3AHAS-MORE" class="xref">HAS-MORE</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:OBJECT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3AOBJECT">OBJECT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>Accessor to the data structure the iterator is iterating over.

Note that this is not necessarily the same object as what was passed into the
constructor of the iterator. The iterator is free to modify this slot as it sees fit.

See <a href="#GENERIC-FUNCTION%20FOR%3AITERATOR" class="xref">ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF OBJECT)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20OBJECT%29">(SETF OBJECT)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NEW-VALUE</li>    <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:PREFETCH"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3APREFETCH">PREFETCH</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>Cache for the next value

Since the iterator constructs provided by CL do not allow merely testing whether a next
element is available without losing it if there is one, we must cache the value on a
HAS-MORE call and then use that on NEXT instead of calling the iterator function twice.

See <a href="#FUNCTION%20FOR%3APACKAGE-ITERATOR" class="xref">PACKAGE-ITERATOR</a>
See <a href="#FUNCTION%20FOR%3AHASH-TABLE-ITERATOR" class="xref">HASH-TABLE-ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF PREFETCH)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20PREFETCH%29">(SETF PREFETCH)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NEW-VALUE</li>    <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:START"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3ASTART">START</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>Accessor to the index that points to the next element of the vector-iterator.</pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF START)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20START%29">(SETF START)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NEW-VALUE</li>    <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:STEP-FUNCTIONS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3ASTEP-FUNCTIONS">STEP-FUNCTIONS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERATOR</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/iterator.lisp#L9">Source</a>  </header> <div class="docstring"><pre>Returns a set of functions to perform the iteration.

Returns four values:

   NEXT      --- Function of zero arguments that returns the next element.
   HAS-MORE  --- Function of zero arguments that returns whether there are
                 more elements available.
   UPDATE    --- Function of one argument that sets the current element to
                 the given value if possible.
   END       --- Function of zero arguments to finalise the iteration.

Iterators may specialise on this method to return tailored stepping
functions that avoid the CLOS dispatch cost. Note that calling these
functions may or may not change the internal iterator state.</pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:TOTAL-LENGTH"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3ATOTAL-LENGTH">TOTAL-LENGTH</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>Slot holding the array-total-size.

See <a href="#CLASS%20FOR%3AARRAY-ITERATOR" class="xref">ARRAY-ITERATOR</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION FOR:(SETF TOTAL-LENGTH)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20FOR%3A%28SETF%20TOTAL-LENGTH%29">(SETF TOTAL-LENGTH)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NEW-VALUE</li>    <li class="argument">OBJECT</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:DEFINE-ACCUMULATION-BINDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-ACCUMULATION-BINDING">DEFINE-ACCUMULATION-BINDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <ul class="arguments"> <li class="argument">VAR</li>  <li class="argument lambda-list-keyword">&amp;REST</li>  <li class="argument">ARGS</li>  <li class="argument lambda-list-keyword">&amp;REST</li> </ul>    <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">BODY</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L154">Source</a>  </header> <div class="docstring"><pre>Defines a binding for an accumulator.

This is identical to DEFINE-FORM-BINDING with the exception that the
secondary value is set to a (RETURN-FOR var) for you, meaning the
variable's contents are returned from the FOR upon normal termination.

See <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-BINDING" class="xref">DEFINE-FORM-BINDING</a></pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:DEFINE-ALIAS-BINDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-ALIAS-BINDING">DEFINE-ALIAS-BINDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <li class="argument">REFERENCED-BINDING-NAME</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L31">Source</a>  </header> <div class="docstring"><pre>Defines an alias for a binding.

See <a href="#FUNCTION%20FOR%3ABINDING" class="xref">BINDING</a></pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:DEFINE-DIRECT-BINDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-DIRECT-BINDING">DEFINE-DIRECT-BINDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <li class="argument">ARGS</li>    <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">BODY</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L35">Source</a>  </header> <div class="docstring"><pre>Defines a binding function.

Binding functions can return three values:

1. A single &quot;surrounding form&quot; that will go around the resulting loop. If you
   require multiple surrounding forms, you can use WITH-INTERLEAVING.
2. A form to run during each iteration. They will be run before any body forms.
3. A form whose value is returned by the FOR.
4. A form to run during each iteration. They will be run *after* any body forms.

The arguments that the function receives are directly translated from the
respective binding expression. One argument will always be passed in the
very least: the variable specified for the binding.

Note that a binding function receives its arguments as literals and thus must
process them like a macro would (destructive operations are bad juju).

Also note that unlike normal functions, the &amp;environment lambda-list argument
is available and its value will be passed on from the calling FOR macro.

See <a href="#FUNCTION%20FOR%3ABINDING" class="xref">BINDING</a>
See <a href="#FUNCTION%20FOR%3AREMOVE-BINDING" class="xref">REMOVE-BINDING</a></pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:DEFINE-FORM-BINDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-BINDING">DEFINE-FORM-BINDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <ul class="arguments"> <li class="argument">VAR</li>  <li class="argument lambda-list-keyword">&amp;REST</li>  <li class="argument">ARGS</li>  <li class="argument lambda-list-keyword">&amp;REST</li> </ul>    <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">BODY</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L151">Source</a>  </header> <div class="docstring"><pre>Defines a binding that receives its arguments as literals.

&amp;AUX variables in the ARGS lambda-list receive special treatment: they are
bound to gensyms within the definition body. Their value is only evaluated
and set within the expanded binding. This means that &amp;AUX variables give you a
convenient way to introduce necessary helper variables to the expanded binding.
References to other AUX variables or the VAR are automatically rewritten to
the appropriate gensym.

VAR can also accept a default value, which receives the same semantic treatment
as &amp;AUX variables do, with the exception that it is always the last binding to
be evaluated in the resulting expansion, meaning every other &amp;AUX variable can
be referenced.

The primary value returned must be the form to be evaluated on each iteration.
A secondary value may be returned, which is a form to be evaluated when the
loop ends normally.

See <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-DIRECT-BINDING" class="xref">DEFINE-DIRECT-BINDING</a>
See <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-VALUE-BINDING" class="xref">DEFINE-VALUE-BINDING</a></pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:DEFINE-FORM-SYMBOL-MACRO-BINDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-SYMBOL-MACRO-BINDING">DEFINE-FORM-SYMBOL-MACRO-BINDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <ul class="arguments"> <li class="argument">VAR</li>  <li class="argument lambda-list-keyword">&amp;REST</li>  <li class="argument">ARGS</li>  <li class="argument lambda-list-keyword">&amp;REST</li> </ul>    <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">BODY</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L161">Source</a>  </header> <div class="docstring"><pre>Defines a binding that receives its arguments as literals and treats the VAR as a symbol-macro.

This is the exact same as DEFINE-FORM-BINDING with the exception that the
VAR is translated into a symbol-macro binding. Its value is still translated
accordingly to make sure references to AUX variables stay intact.

See <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-BINDING" class="xref">DEFINE-FORM-BINDING</a></pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:DEFINE-VALUE-BINDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-VALUE-BINDING">DEFINE-VALUE-BINDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <ul class="arguments"> <li class="argument">VAR</li>  <li class="argument lambda-list-keyword">&amp;REST</li>  <li class="argument">ARGS</li>  <li class="argument lambda-list-keyword">&amp;REST</li> </ul>    <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">BODY</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L164">Source</a>  </header> <div class="docstring"><pre>Defines a binding that receives its arguments as values.

The treatment of all arguments in the ARGS lambda-list is as follows:
Within the definition body, they are bound to gensyms. Upon expansion of the
binding, each variable is expanded to a variable binding with the respective
value that was passed to the binding definition. Special exception is made for
the present-p optional variables that can be specified for optional or key
arguments, which are bound as usual in the definition body such that expansion
may be aware of which parameters were passed. In essence, you can interpret all
arguments as if treated by ONCE-ONLY.

&amp;AUX variables in the args lambda-list receive special treatment: they are
bound to gensyms within the definition body. Their value is only evaluated
and set within the expanded binding. This means that AUX variables give you a
convenient way to introduce necessary helper variables to the expanded binding.
References to other arguments or the VAR are automatically rewritten to
the appropriate gensym.

VAR can also accept a default value, which receives the same semantic treatment
as &amp;AUX variables do, with the exception that it is always the last binding to
be evaluated in the resulting expansion, meaning every other argument can
be referenced.

The primary value returned must be the form to be evaluated on each iteration.
A secondary value may be returned, which is a form to be evaluated when the
loop ends normally.

See <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-FORM-BINDING" class="xref">DEFINE-FORM-BINDING</a>
See <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-DIRECT-BINDING" class="xref">DEFINE-DIRECT-BINDING</a></pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:DEFINE-VALUE-SYMBOL-MACRO-BINDING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-VALUE-SYMBOL-MACRO-BINDING">DEFINE-VALUE-SYMBOL-MACRO-BINDING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">NAME</li>    <ul class="arguments"> <li class="argument">VAR</li>  <li class="argument lambda-list-keyword">&amp;REST</li>  <li class="argument">ARGS</li>  <li class="argument lambda-list-keyword">&amp;REST</li> </ul>    <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">BODY</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/binding.lisp#L168">Source</a>  </header> <div class="docstring"><pre>Defines a binding that receives its arguments as values and treats the VAR as a symbol-macro.

This is the exact same as DEFINE-VALUE-BINDING with the exception that the
VAR is translated into a symbol-macro binding. Its value is still translated
accordingly to make sure references to arguments stay intact.

See <a href="#MACRO-FUNCTION%20FOR%3ADEFINE-VALUE-BINDING" class="xref">DEFINE-VALUE-BINDING</a></pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:FOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3AFOR">FOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">BINDINGS</li>    <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">BODY</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/for.lisp#L25">Source</a>  </header> <div class="docstring"><pre>Loops the body with the given bindings established.

Each binding should have the form (var binding-type args*)

Sometimes a var can be either a single symbol denoting a variable, or a
lambda-list to which the result is destructured and bound via UPDATE.
The support thereof depends on the binding construct.

Within the body, special iteration clauses may be present. A clause must appear
at the &quot;top-level&quot; of the body and cannot appear as a macro-expansion.

If the loop is terminated normally by END-FOR then multiple values may be returned
depending on how many bindings or clauses are present that want to return values.
The order of the values is as follows: the clause values are returned in the
order that the clauses appear in the body, followed by the binding values in the
order of the binding expressions.

The loop may also be terminated abnormally by a direct call to RETURN-FOR or RETURN.

See <a href="#MACRO-FUNCTION%20FOR%3AUPDATE" class="xref">UPDATE</a>
See <a href="#FUNCTION%20FOR%3ABINDING" class="xref">BINDING</a>
See <a href="#FUNCTION%20FOR%3ACLAUSE" class="xref">CLAUSE</a>
See END-FOR
See SKIP-FOR
See RETURN-FOR
See <a href="#MACRO-FUNCTION%20FOR%3AWITH-FOR-TAGBODY" class="xref">WITH-FOR-TAGBODY</a>
See <a href="#MACRO-FUNCTION%20FOR%3AWITH-FOR-BLOCK" class="xref">WITH-FOR-BLOCK</a>
See <a href="#FUNCTION%20FOR%3ACONVERT-BINDINGS" class="xref">CONVERT-BINDINGS</a>
See <a href="#FUNCTION%20FOR%3ACONVERT-CLAUSES" class="xref">CONVERT-CLAUSES</a></pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:UNLESS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3AUNLESS">UNLESS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">TEST</li>    <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">FORMS</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>If the first argument is not true, the rest of the forms are
evaluated as a PROGN.</pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:UPDATE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3AUPDATE">UPDATE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PLACE</li>    <li class="argument">VALUE-FORM</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/toolkit.lisp#L49">Source</a>  </header> <div class="docstring"><pre>Allows updating the PLACE with a new value.

Unlike just (setf place value), PLACE can also be a lambda-list where each variable
is then properly updated with the respective element from value list.</pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:WHEN"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3AWHEN">WHEN</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">TEST</li>    <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">FORMS</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  </header> <div class="docstring"><pre>If the first argument is true, the rest of the forms are
evaluated as a PROGN.</pre></div> </article> </li>  <li> <article class="definition macro callable" id="MACRO-FUNCTION FOR:WITH-INTERLEAVING"> <header> <span class="visibility">EXTERNAL</span> <span class="type">MACRO</span> <h4 class="name"> <a href="#MACRO-FUNCTION%20FOR%3AWITH-INTERLEAVING">WITH-INTERLEAVING</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;BODY</li>    <li class="argument">BODY</li>    <li class="argument lambda-list-keyword">&amp;REST</li>  </ul>  <a class="source-link" href="https://github.com/Shinmera/for/blob/70ce428c72e7850892a77b66e2844336620859ba/toolkit.lisp#L24">Source</a>  </header> <div class="docstring"><pre>Interleave the body forms.

Essentially this means that the last form is appended to the form before it
and this is then appended to the form before that, and so on.</pre></div> </article> </li>  <li> <article class="definition optimizer" id="OPTIMIZER FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">OPTIMIZER</span> <h4 class="name"> <a href="#OPTIMIZER%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition optimizer" id="OPTIMIZER FOR:APPEND"> <header> <span class="visibility">EXTERNAL</span> <span class="type">OPTIMIZER</span> <h4 class="name"> <a href="#OPTIMIZER%20FOR%3AAPPEND">APPEND</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/srctran.lisp#248:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition optimizer" id="OPTIMIZER FOR:APPEND"> <header> <span class="visibility">EXTERNAL</span> <span class="type">OPTIMIZER</span> <h4 class="name"> <a href="#OPTIMIZER%20FOR%3AAPPEND">APPEND</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#600:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition optimizer" id="OPTIMIZER FOR:COUNT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">OPTIMIZER</span> <h4 class="name"> <a href="#OPTIMIZER%20FOR%3ACOUNT">COUNT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:COUNT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3ACOUNT">COUNT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition source-transform" id="SOURCE-TRANSFORM FOR:APPEND"> <header> <span class="visibility">EXTERNAL</span> <span class="type">SOURCE-TRANSFORM</span> <h4 class="name"> <a href="#SOURCE-TRANSFORM%20FOR%3AAPPEND">APPEND</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/srctran.lisp#205:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:APPEND"> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3AAPPEND">APPEND</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:APPEND"> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3AAPPEND">APPEND</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition source-transform" id="SOURCE-TRANSFORM FOR:(SETF APPEND)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">SOURCE-TRANSFORM</span> <h4 class="name"> <a href="#SOURCE-TRANSFORM%20FOR%3A%28SETF%20APPEND%29">(SETF APPEND)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/srctran.lisp#205:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition optimizer" id="OPTIMIZER FOR:NCONC"> <header> <span class="visibility">EXTERNAL</span> <span class="type">OPTIMIZER</span> <h4 class="name"> <a href="#OPTIMIZER%20FOR%3ANCONC">NCONC</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/srctran.lisp#248:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition optimizer" id="OPTIMIZER FOR:NCONC"> <header> <span class="visibility">EXTERNAL</span> <span class="type">OPTIMIZER</span> <h4 class="name"> <a href="#OPTIMIZER%20FOR%3ANCONC">NCONC</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#616:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition source-transform" id="SOURCE-TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">SOURCE-TRANSFORM</span> <h4 class="name"> <a href="#SOURCE-TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition source-transform" id="SOURCE-TRANSFORM FOR:(SETF =)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">SOURCE-TRANSFORM</span> <h4 class="name"> <a href="#SOURCE-TRANSFORM%20FOR%3A%28SETF%20%3D%29">(SETF =)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition source-transform" id="SOURCE-TRANSFORM FOR:NCONC"> <header> <span class="visibility">EXTERNAL</span> <span class="type">SOURCE-TRANSFORM</span> <h4 class="name"> <a href="#SOURCE-TRANSFORM%20FOR%3ANCONC">NCONC</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/srctran.lisp#216:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:NCONC"> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3ANCONC">NCONC</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition source-transform" id="SOURCE-TRANSFORM FOR:(SETF NCONC)"> <header> <span class="visibility">EXTERNAL</span> <span class="type">SOURCE-TRANSFORM</span> <h4 class="name"> <a href="#SOURCE-TRANSFORM%20FOR%3A%28SETF%20NCONC%29">(SETF NCONC)</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/srctran.lisp#216:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition transform" id="TRANSFORM FOR:="> <header> <span class="visibility">EXTERNAL</span> <span class="type">TRANSFORM</span> <h4 class="name"> <a href="#TRANSFORM%20FOR%3A%3D">=</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/linus/Projects/c/sbcl/src/compiler/knownfun.lisp#22:0">Source</a>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li>  <li> <article class="definition optimizer" id="OPTIMIZER FOR:REDUCE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">OPTIMIZER</span> <h4 class="name"> <a href="#OPTIMIZER%20FOR%3AREDUCE">REDUCE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> </article> </li> </ul> </article> </li> </ul> </section>  </article> <script>window.addEventListener("DOMContentLoaded", function(){
    var unmarkElement = function(el){
        if(el.tagName === "mark" || el.tagName === "MARK"){
            [].forEach.call(el.childNodes, function(child){
                el.parentNode.insertBefore(child, el);
            });
            el.parentNode.removeChild(el);
        }else if(el.parentNode.tagName === "mark"){
            return unmarkElement(el.parentNode);
        }
        return null;
    }

    var unmarkAll = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("mark"), unmarkElement);
    }
    
    var markElement = function(el){
        if(el.parentNode.tagName === "mark" || el.parentNode.tagName === "MARK"){
            return el.parentNode;
        } else {
            unmarkAll();
            var marked = document.createElement("mark");
            el.parentNode.insertBefore(marked, el);
            marked.appendChild(el);
            return marked;
        }
    }

    var markFragmented = function(){
        if(window.location.hash){
            var el = document.getElementById(decodeURIComponent(window.location.hash.substr(1)));
            if(el) markElement(el);
        }
    }

    var registerXrefLink = function(link){
        var el = document.getElementById(decodeURIComponent(link.getAttribute("href").substr(1)));
        if(el){
            link.addEventListener("click", function(){
                markElement(el);
            });
        }
    }

    var registerXrefLinks = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("a.xref"), registerXrefLink);
    }

    markFragmented();
    registerXrefLinks();
}); </script> </body> </html> 